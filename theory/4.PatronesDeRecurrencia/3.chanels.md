# Chanels

Como ya vimos los chanel es un forma de comunicarse entre go routines puedes enviar o recibir informacion de los canales.

## Como usar

``` go
func main(){
    // Creamos un canal que regresara un string
    message:= make(chan string)
    go func(){
        // Ahora devolvemos el string
        message <- "Hola desde el cana"
    }()
    // El mensaje lo guaramos en la variable msg
    msg:= <-message
}

```

## Tipos de canales

Cuando hablamos de canales tenemos de 2 tipos con buffer y sin buffer.

### Sin Buffer

La go Routine que envia se bloquea hasta que otra go routine reciba el valor.

``` go
func main(){
    message:= make(chan string)
    go func(){
        message <- "Hola desde el cana"
    }()
    msg:= <-message
}
```

El ejemplo solo puedes ver una go routine que es donde dice go tener en cuenta que la funcion main actua como un go routine entonces si lo estamos recibiendo en una go routine.

### Con buffer

Nos va a permitir mandar valores sin bloquearse hasta que el buffer este lleno.

``` go

func main(){
    // Creamos un canal con buffer es decir con 2 valores sin que se bloque
    messages := make(chan string,2)
    // Agregamos 2 valores
    message <- "hola"
    message <- "Mundo"
    fmt.Println(<-message) // sacamos el valor
    fmt.Println(<-message) // sacamos el valor    
}
```

### Reestriccion de canales

***Canales de lectura:***
Para definir que un canal es solo de lectura lo hacemos de la siguiente forma

``` go
// Este canal es solo de lectura
func worker(jobs <-chan int) // <- esto lo indica cuando va despues del chan
```
***Canales de esrcritura:***

``` go
// Canal solo de escritura
func worker(jobs chan<- int){} // chan <- indica que solo se puede agregar un valor

```

***Canales sin Restricciones:***

``` go
// Canal de lectura o escritura
func worker(jobs chan int){} // solo no colocamos ninguna flecha.
```

***Resumen:***

``` go
// Solo Lectura
func worker(jobs <-chan int){}

// Solo Escritura
func worker(jobs chan<- int){}

// sin Restriccion
func worker(jobs chan int){}
```


***Ejemplo***
Vamos a ver un ejemplo con varios canales y varias go 

``` go
func worker(id int, jobs <-chan int, results chan<- int){
    // Este for NO termina inmediatamente
    // Se queda ESPERANDO hasta que lleguen valores o se cierre jobs
    for j:= range jobs{
        fmt.Printf("Trabajador %d empezo trabajo %d\n",id,j)
        time.Sleep(time.Second)
          fmt.Printf("Trabajador %d termino trabajo %d\n",i,j)
        results <- j * 2
    }
}


func main(){
    // Creamos 2 canales con buffer 100
    jobs := make(chan int,100)
    results := make(chan int, 100)

    // Mandamos 3 valores 1,2,3
    for w:=1,w<=3;w++{
        go worker(w, jobs,results)
    }
    // En este momento: los 3 workers están ESPERANDO en "for j := range jobs"
    // porque jobs está VACÍO (pero NO cerrado)

    // Metemos valores a jobs del 1 al 5
    for j:=1;j<=5;j++{
        jobs <- j
    }

    // cerramos canales 
    close(jobs)
    for a:=1;a<=5; a++{
        fmt.Println("Resultado", <-results)
    }
}


```

Clave: Los canales en Go hacen que las goroutines esperen automáticamente, por eso funciona aunque jobs esté vacío al inicio.