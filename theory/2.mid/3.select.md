# Select
 
Permite a un go rountine esperar multiples operaciones de canal simultaneamente.Pero cuando termine uno entonces sigue la ejecucion es decir ignora los demas case.


``` go
func main(){
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func(){ch1 <- "Channel 1"}()
    go func(){ch1 <- "Channel 2"}()

    select {
        // entrara hasta que uno de los canales tenga el valor
        case msg1:= <-ch1:
            fmt.Println(msg1)
        case msg2:= <-ch2:
            fmt.Println(msg2)

    }
}

```

Aqui esta escuchando varios canales y cuando uno resuelva entonces ejecuta el case.

## Canal con timeout.

Como trabajar cuando un canal tarda demasiado, lo que pasa aqui es que after regresa un canal, cuando este termina entonces la funcion main acaba, esto es porque no espera a que todos los go routine termine si no solo el primero


``` go

func main(){

    go func(){
        time.Sleep(2 * time.Second)
        ch <- "Done"
    }()

    select 
    case msg := <- ch:
        fmt.Println(msg)
    case <-time.After(1*time.Second):
        fmt.Println("TimeOut")

}

```

pero y si quiero que espere todo


``` go

func main(){

    go func(){
        time.Sleep(2 * time.Second)
        ch <- "Done"
    }()

    select 
    case msg := <- ch:
        fmt.Println(msg)
    case <-time.After(1*time.Second):
        fmt.Println("TimeOut")

}
    newMsg:= <- ch // Aqui si esperario todos


```

## Mas de un canal?
Puedes crear un buffer y luego mandar a recorrerlos para recibir esos valores


``` go


func main(){
    ch := make(chan string, 3)  // Buffer de 3
    
    go func(){
        ch <- "Valor1"  // No se bloquea
        ch <- "Valor2"  // No se bloquea
        ch <- "Valor3"  // No se bloquea
        close(ch)       // Indica que no habrá más valores
    }()
    
    // Recibe hasta que el canal se cierre
    for msg := range ch {
        fmt.Println(msg)
    }
}

// el close(ch) es muy importante por que msg va a recorrer hasta que se haya cerrado, si no seguira bucando mas y mas valores y esto hace que falle el programa.
```

Tambien puedes comprobar si el canal ya esta cerrado

``` go

for {
    msg, ok := <-ch
    if !ok {  // Si el canal está cerrado
        break
    }
    fmt.Println(msg)
}
```