# Channels

Es la forma de comunicacion entre go routines. Es una forma de mandar o recibir datos entre ellos.

Los canales siguen el principio de Go, no comuniques compartiendo memoria, comparte memoria comunicando.


``` go
// make -> crear
// cha int -> un canal tipo int
ch:= make(chan int)

```


``` go
func main(){
    ch := make(chan int)
    go func(){
        // enviamos este valor hacia el canal
        ch <- 42
    }()
    // ahora val recibiera el valor que tiene es 42
    val := <- ch
}

```

Nosotros sabemos que Go routines son asincronos es decir no espera a que la funcion mandada a otro hilo termine, el hilo principal sigue ejecutando codigo de manera normal, ahora con ch si va a esperar a que ch devuelva el valor, si va a detener su ejecucion , pausara  hasta que obtenga el valor retornado y cuando termine entonces continuara.


## Canal con buffer
Un buffer es como un contedor de datos entonces tendremos quien llena la caja y quien toma lo que hay en la caja

Un canal con buffer puede guardar multiples valores antes de bloquearse.

Ejemplo: 1 buffer

``` go
func main(){
    // no definimos el buffer 
    ch:= make(chan int)
    // Llenamos valor
    go func(){
        ch <- "Hola"
    }()

    // espera a que ch tenga valor, 
    val:= <- ch
}

```
Simple

- Esperamos que el emisor y el reseptor se sincronicen.

- Se bloquea el receptor por esperar la respuesta


#### Buffer > 1

Podemos producir guardar mas valores de los que se empaqueten dando como resultado, trabajo mas rapido, esto es porque los canales pueden guardar varios valores


``` go
func main(){
    // Inicializamos 10  espacios
    ch:= make(chan int,100)
    // Llenamos valor
    for i range 100{
    go func(i){
        ch <-i // envia varios sin bloquearse
    }(i)
        }

    // espera a que ch tenga valor, 
       go func() {
        for trabajo := range ch {
            fmt.Println("Procesando:", trabajo) // los procesa todos sin problema
            time.Sleep(50 * time.Millisecond)
        }
    }()
}

```



``` go
func main(){
    // Inicializamos 3
    ch:= make(chan int,3)
   
    for i range 100{
    go func(i){
        ch <-i // solo se mandan 3 y los demas esperan a que haya espacio
    }(i)
        }

    // espera a que ch tenga valor, 
       go func() {
        for trabajo := range ch {// procesa 3 y cuando se vacia se bloquea
            fmt.Println("Procesando:", trabajo) 
            time.Sleep(50 * time.Millisecond)
        }
    }()
}

```


El main seguira haciendo su trabajo, pero si puede darse como este ultimo caso que se bloquen ambas ejecuciones