# GoRoutine

Es un hilo de ejecucion ligero en el lenguaje que permite ejecutar funciones de forma concurrent


## Hilo ligero o lightWeight thread

***¿Por que se dice que Go es Hilo ligero?***
Un hilo ligero consume menos recursos que un hilo tradicional.

Usa algo llamado multiplexa.

### Multiplexa

Multiplexa es una forma de manejar varios datos en una misma via Ejemplo.

Personas en un tren, todos van en un mismo tren pero en diferentes vagones, el tren seria el hilo pero a pesar de que viajan en el mismo tren,van en diferentes vagones es decir movilisamos mas gente con un solo tren en este caso en el mismo hilo con algo que los diferencia tiempo, tamaño,etc.. seria el vagon.

***Hilos tradicionales:***
- Consumen mas memoria de 1 a 2 MB cada uno.
- Son gestionados por el sistema operativo.
- Cambiar entre hilos es costoso.
- No se pueden crear millones.

***Goroutines:***
- Consumen 2kb de memorial incial.
- son Gestionados por el runtime de Go.
- El cambio entre goroutines es muy rapido.
- Puedes crear millones sin problema.

# Runtime Go y compilador

Aqui vamos a hacer incapie en que es un runtime y que es un compilador y sus diferencia.


***Compilador:***
El compilador es el encargado de convertir tu el codigo que escribiste a 0s y 1s que es lo que la computadora puede entender. Con esto tenemos que tener en cuenta a la arquitectura del procesador es decir, la pc solo entiende 0s y 1s, podemos decir que 00 es hola y 11 es adios, esto seria el lenguaje de la pc, pero puede ser que para otro tipo de arquitectura 11 es hola y 00 es adios por eso tenemos que convertirlo a la arquitectura.

Tambien hay que aclarar que despues de compilar tu codigo ya no necesita tener instalado el compilador.

***Run time:***
Puede ser el timpo de ejecucion de un programa, o el entorno en donde se ejecuta como tu pc, Tambien puede referirce a todas las cosas necesarias para que tu programa pero no son Bibliotecas como fmt, io o http.

Ejemplo:


- Garbage collector
- Gestion de memoria
- Manejo de panic/recover
- Sistema de tipos en tiempo de ejecucion
- Scheduler de gorotines -> planifica que se ejecuta


Ahora en resumen

El runtime es el motor que hace que Go funcione como Go. Es lo que le da sus características especiales:

Goroutines ligeras → gracias al scheduler del runtime.

Garbage collection automático → gracias al GC del runtime.

No tienes que liberar memoria manualmente → el runtime lo hace.

Panic/recover funcionan → el runtime los maneja.

Y las bibliotecas son simplemente código Go útil ya escrito para ti (como fmt, http, json), pero no son nada "mágico" - podrías escribir tu propia versión si quisieras.

# Concurrencias y paralelismo

Go se dice que cuando trabajamos con Gorutines trabaja concurrente, pero ¿que es?

## Concurrencia
La concurrencia son multiples tareas prograsan en periodos de tiempo superpuestos, pero no necesariamente al mismo tiempo, es como cocinar varias cosas a la ves, y vas cambiando de plato

## Paralelismo
Esto si es multiples tareas ejecutandose a la misma ves en diferente nucleo de CPU. seria como varias personas cocinando.

Go puede ser concurrente y tambien paralelo. Los goroutines se turnan en un solo nucleo.

Todo esto puede parecer como si Go trabajara de forma secuencial pero no es asi.

La funcion que empieza con go no detiene el flujo principal, y se ejecuta al lado de las demas
Ejemplo:

``` go


func descargarArchivo(nombre string) {
    fmt.Println("Descargando", nombre)
    time.Sleep(2 * time.Second) // Simula descarga
    fmt.Println("Terminó", nombre)
}



func main() {
    go descargarArchivo("archivo1.pdf")  // No espera
    go descargarArchivo("archivo2.pdf")  // No espera
    go descargarArchivo("archivo3.pdf")  // No espera
    
    time.Sleep(3 * time.Second) // Espera que terminen
    // Total: ~2 segundos (todas en paralelo/concurrente)
}

```

Pero tambien depende el tipo de espera que quieras hacer


- For muy grande -> Bloquea
- time.sleep -> espera
- http.get -> espera
- archivo.read -> espera