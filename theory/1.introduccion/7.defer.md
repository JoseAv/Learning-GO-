# Defer
Palabra reservada para indicar alguna linea que queremos que se ejecute de ultimo, es util para limpiar memoria, o algo que queramos hacer al final.

***Ejemplo:***

``` go
func main(){
    defer fmt.println("Esto es de ultimo")

    fmt.println("Esto es primero")
}


// El resultado sera, Primero saldra
// Esto es primero
// Esto es de ultimo

```

aunque yo defini un print arriba de otro, el defer lo dejara para lo ultimo

## Multiples difer
Se puede definir varios difer esto funcionara como una pila

``` go
func main (){
    defer fmt.Println("1. primero")
    defer fmt.Println("2. segundo")
    defer fmt.Println("3. tercero")
}
// Orde de salida

"3. tercero"
"2. segundo"
"1. primero"

```

## Defer con funciones

Si tambien es posible hacer esto 

``` go

func close(){
     fmt.Println("cerrar")
}

func open(){
    defer close()

     fmt.Println("Abriendo")
    
    return nil
}

open()

// Orden de salida

"Abriendo"
"cerrar"

```


## Recursividad

Nosotros podemos usar defer en recursivo pero este se va a ejecutar cuando la funcion termine es decir desde el ultimo llamado hasta el primero

``` go

func recursiva(n int) {
    defer fmt.Println("Saliendo nivel:", n)
    
    if n > 0 {
        recursiva(n - 1)
    }
    
    fmt.Println("Ejecutando nivel:", n)
}

func main() {
    recursiva(3)
}

// Salida:
// Ejecutando nivel: 0
// Saliendo nivel: 0
// Ejecutando nivel: 1
// Saliendo nivel: 1
// Ejecutando nivel: 2
// Saliendo nivel: 2
// Ejecutando nivel: 3
// Saliendo nivel: 3

```

## Casos especiales o a tener en cuenta

Cuando nosotros usamos un defer los argumentos se evaluan en ese instante.

``` go
func main(){
    i:=0
    defer fmt.Println(i) // Aqui ya vale cero siempre

    i++
    fmt.Println(i) // este si vale 1
}

```

Esto pueda arreglarse si lo que se quiere es solo obtener el ultimo valor y es con una funcion anonima

``` go
func main(){
    i:=0
    defer func(){
        fmt.Println(i) // valor 1
    }()

    i++
     fmt.Println(i) // valor 1

}

// Podemos pasar el argumento a la funcion y pasaria esto



func main(){
    i:=0
    defer func(i){
        fmt.Println(i) // valor 0 -> Aqui ya comprobo ese argumento y lo guardo
    }(i)

    i++
     fmt.Println(i) // valor 1

}

```

Tiene el mismo comportamiento en los arreglos

``` go

func loopIncorrecto() {
    for i := 0; i < 3; i++ {
        defer fmt.Println(i)  // evalúa i inmediatamente
    }
}
// Salida: 2, 1, 0 ✓

func loopConParametro() {
    for i := 0; i < 3; i++ {
        defer func(val int) {
            fmt.Println(val)
        }(i)  // evalúa i inmediatamente
    }
}
// Salida: 2, 1, 0 ✓

func loopSinParametro() {
    for i := 0; i < 3; i++ {
        defer func() {
            fmt.Println(i)  // captura i por referencia
        }()
    }
}
// Salida: 3, 3, 3 ← todas ven i=3 al final

```